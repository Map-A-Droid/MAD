{% extends "base.html" %}

{% block header %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin="" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/css/leaflet-sidebar.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
<link rel="stylesheet" href="static/style/madmin.css?1561125653674" />
{% endblock %}

{% block scripts %}
<script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>
<script src="https://vuejs.org/js/vue.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/js/leaflet-sidebar.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"></script>
<script>
  var locInjectBtn = L.easyButton({
    position: "bottomright",
    states: [{
      stateName: 'scanmode-activate',
      icon: 'fa-satellite-dish',
      title: 'Enable click-to-scan mode',
      onClick: function(btn, map) {
        clickToScanActive = true;
        L.DomUtil.addClass(map._container, 'crosshair-cursor-enabled');
        btn.state('scanmode-deactivate');
      }
    }, {
      stateName: 'scanmode-deactivate',
      icon: 'fa-satellite-dish',
      title: 'Disable click-to-scan mode',
      onClick: function(btn, map) {
        clickToScanActive = false;
        L.DomUtil.removeClass(map._container, 'crosshair-cursor-enabled');
        btn.state('scanmode-activate');
      }
    }]
  });

  $(document).on("hidden.bs.modal", "#injectionModal", function(e) {
    locInjectBtn.state("scanmode-activate");
    clickToScanActive = false;
    L.DomUtil.removeClass(map._container, 'crosshair-cursor-enabled');
  });

  L.Marker.addInitHook(function() {
    if (this.options.virtual) {
      this.on('add', function() {
        this._updateIconVisibility = function() {
          if (!this._map) {
            return;
          }
          var map = this._map;
          var isVisible = map.getBounds().contains(this.getLatLng());
          var wasVisible = this._wasVisible;
          var icon = this._icon;
          var iconParent = this._iconParent;
          var shadow = this._shadow;
          var shadowParent = this._shadowParent;

          if (!iconParent) {
            iconParent = this._iconParent = icon.parentNode;
          }
          if (shadow && !shadowParent) {
            shadowParent = this._shadowParent = shadow.parentNode;
          }

          if (isVisible != wasVisible) {
            if (isVisible) {
              iconParent.appendChild(icon);
              if (shadow) {
                shadowParent.appendChild(shadow);
              }
            } else {
              iconParent.removeChild(icon);
              if (shadow) {
                shadowParent.removeChild(shadow);
              }
            }

            this._wasVisible = isVisible;

          }
        };

        this._map.on('resize moveend zoomend', this._updateIconVisibility, this);
        this._updateIconVisibility();

      }, this);
    }
  });

  // globals
  var map;
  var sidebar;
  var init = true;
  var fetchTimeout = null;
  var clickToScanActive = false;

  // object to hold all the markers and elements
  var leaflet_data = {
    tileLayer: "",
    raids: {},
    spawns: {},
    quests: {},
    gyms: {},
    routes: {},
    geofences: {},
    workers: {},
    mons: {},
    monicons: {}
  };

  new Vue({
    el: '#app',
    data: {
      raids: {},
      gyms: {},
      quests: {},
      spawns: {},
      mons: {},
      layers: {
        stat: {
          spawns: false,
          gyms: false,
          quests: false,
          workers: false,
          mons: false
        },
        dyn: {
          routes: {},
          geofences: {}
        }
      },
      workers: {},
      maptiles: {
        cartodblight: {
          name: "CartoDB Positron",
          url: "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
        },
        cartodbdark: {
          name: "CartoDB Darkmatter",
          url: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png"
        },
        cartodbvoyager: {
          name: "CartoDB Voyager",
          url: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
        },
        osm: {
          name: "OpenStreetMap",
          url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        },
        osmhot: {
          name: "OpenStreetMap HOT",
          url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png"
        },
        wikimedia: {
          name: "Wikimedia",
          url: "https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png"
        },
        hydda: {
          name: "Hydda",
          url: "https://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png"
        }
      },
      settings: {
        maptiles: "cartodblight",
        routes: {
          coordinateRadius: {
            raids: 490,
            quests: 40,
            mons: 67
          }
        }
      }
    },
    watch: {
      "layers.stat.gyms": function(newVal, oldVal) {
        if (newVal && !init) {
          this.map_fetch_gyms(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("raids", oldVal, newVal);
        this.changeStaticLayer("gyms", oldVal, newVal);
      },
      "layers.stat.spawns": function(newVal, oldVal) {
        if (newVal && !init) {
          this.map_fetch_spawns(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("spawns", oldVal, newVal);
      },
      "layers.stat.workers": function(newVal, oldVal) {
        if (newVal && !init) {
          this.map_fetch_workers(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("workers", oldVal, newVal);
      },
      "layers.stat.quests": function(newVal, oldVal) {
        if (newVal && !init) {
          this.map_fetch_quests(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("quests", oldVal, newVal);
      },
      "layers.stat.mons": function(newVal, oldVal) {
        if (newVal && !init) {
          this.map_fetch_mons(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("mons", oldVal, newVal);
      },
      "layers.dyn.geofences": {
        deep: true,
        handler: function() {
          this.changeDynamicLayers("geofences");
        }
      },
      "layers.dyn.routes": {
        deep: true,
        handler: function() {
          this.changeDynamicLayers("routes");
        }
      },
      'settings.maptiles': function(newVal) {
        this.updateStoredSetting("settings-maptiles", newVal);
        leaflet_data.tileLayer.setUrl(this.maptiles[newVal].url);
      },
      'settings.routes.coordinateRadius': {
        deep: true,
        handler: function () {
          $this = this;
          for (routetype in this.settings.routes.coordinateRadius) {
            this.updateStoredSetting('settings-coordinateRadius-' + routetype, this.settings.routes.coordinateRadius[routetype]);
          }

          for (route in leaflet_data["routes"]) {
            leaflet_data["routes"][route].eachLayer(function(marker) {
              try {
                marker.setRadius($this.settings.routes.coordinateRadius[$this.layers.dyn.routes[route].mode]);
              } catch(e) {
                // routes have a special layer containing polylines
                // unfortunately, there's no identifer for them, thus
                // we catch this exception and ignore it
              }
            });
          }
        }
      }
    },
    mounted() {
      // reset some vars
      this.removeStoredSetting("fetchTimestamp");
      this.removeStoredSetting("oSwLat");
      this.removeStoredSetting("oSwLon");
      this.removeStoredSetting("oNeLat");
      this.removeStoredSetting("oNeLon");

      // init our map first
      this.initMap();

      // initial load
      this.map_fetch_everything();

      // frequently fetch updated data
      setInterval(this.map_fetch_everything, 6000);
    },
    methods: {
      map_fetch_everything() {
        urlFilter = this.buildUrlFilter();

        this.map_fetch_workers();
        this.map_fetch_gyms(urlFilter);
        this.map_fetch_routes();
        this.map_fetch_geofences();
        this.map_fetch_spawns(urlFilter);
        this.map_fetch_quests(urlFilter);
        this.map_fetch_mons(urlFilter);

        this.updateBounds(true);
      },
      map_fetch_workers() {
        var $this = this;

        axios.get("get_position").then(function (res) {
          res.data.forEach(function (worker) {
            var name = worker["name"];

            if ($this["workers"][name]) {
              leaflet_data["workers"][name].setLatLng([worker["lat"], worker["lon"]])

              if (map.hasLayer(leaflet_data["workers"][name])) {
                leaflet_data["workers"][name].bringToFront();
              }
            } else {
              $this.workers[name] = worker;

              leaflet_data["workers"][name] = L.circleMarker([worker['lat'], worker['lon']], {
                radius: 7,
                color: '#E612CB',
                fillColor: '#E612CB',
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.9
              }).bindPopup(name);

              $this.addMouseEventPopup(leaflet_data["workers"][name]);

              if ($this.layers.stat.workers) {
                leaflet_data["workers"][worker["name"]].addTo(map);
              }
            }
          });
        });
      },
      map_fetch_gyms(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.gyms) {
          return;
        }

        axios.get('get_gymcoords' + urlFilter).then(function (res) {
           res.data.forEach(function (gym) {
            switch (gym['team_id']) {
              default:
                color = '#888';
                break;
              case 1:
                color = '#0C6DFF';
                break;
              case 2:
                color = '#FC0016';
                break;
              case 3:
                color = '#FD830E';
                break;
            }

            var skip = true;
            if ($this["gyms"][gym["id"]]) {
              // check if we should update an existing gym
              if ($this["gyms"][gym["id"]]["team_id"] != gym["team_id"]) {
                map.removeLayer(leaflet_data["gyms"][gym["id"]]);
                delete leaflet_data["gyms"][gym["id"]];
              } else {
                skip = false;
              }
            }

            if (skip) {
              // store gym meta data
              $this["gyms"][gym["id"]] = gym;

              leaflet_data["gyms"][gym["id"]] = L.circle([gym['lat'], gym['lon']], {
                id: gym["id"],
                radius: Math.pow((20 - map.getZoom()), 2.5),
                color: color,
                fillColor: color,
                weight: 2,
                opacity: 1.0,
                fillOpacity: 0.8,
              }).bindPopup($this.build_gym_popup, { 'className': 'gympopup'});

              $this.addMouseEventPopup(leaflet_data["gyms"][gym["id"]]);

              // only add them if they're set to visible
              if ($this.layers.stat.gyms) {
                leaflet_data["gyms"][gym["id"]].addTo(map);
              }
            }

            if ($this["raids"][gym["id"]]) {
              /// TODO remove past raids
              // end time is different -> new raid
              if ($this["raids"][gym["id"]]["end"] != gym["raid"]["end"] || gym["raid"]["end"] > (new Date().getTime()/1000)) {
                map.removeLayer(leaflet_data["raids"][gym["id"]]);
                delete leaflet_data["raids"][gym["id"]];
              }
            }

            if (gym["raid"] != null && gym["raid"]["end"] > (new Date().getTime()/1000)) {
              if (map.hasLayer(leaflet_data["raids"][gym["id"]])) {
                return;
              }

              $this["raids"][gym["id"]] = gym["raid"];

              var icon = L.divIcon({
                html: gym["raid"]["level"],
                className: "raidIcon",
                iconAnchor: [-1*(18 - map.getZoom()), -1*(18 - map.getZoom())]
              });

              leaflet_data["raids"][gym["id"]] = L.marker([gym["lat"], gym["lon"]], {
                id: gym["id"],
                icon: icon,
                interactive: false
              });

              leaflet_data["raids"][gym["id"]].addTo(map);
            }
          });
        });
      },
      map_fetch_routes() {
        var $this = this;

        axios.get("get_route").then(function (res) {
          res.data.forEach(function (route) {
            var group = L.layerGroup();
            var coords = [];

            var name = route.name;
            var color = $this.getRandomColor();

            if ($this.layers.dyn.routes[name]) {
              return;
            }

            if (route.mode == "mon_mitm") {
              mode = "mons";
              cradius = $this.settings.routes.coordinateRadius.mons;
            } else if (route.mode == "pokestops") {
              mode = "quests";
              cradius = $this.settings.routes.coordinateRadius.quests;
            } else if (route.mode == "raids_mitm" || route.mode == "raids_ocr") {
              mode = "raids";
              cradius = $this.settings.routes.coordinateRadius.raids;
            }

            route.coordinates.forEach(function (coord) {
              circle = L.circle(coord, {
                pane: "routes",
                radius: cradius,
                color: color,
                fillColor: color,
                fillOpacity: 1,
                weight: 1,
                opacity: 0.4,
                fillOpacity: 0.1
              });

              circle.addTo(group);
              coords.push(circle);
            });

            var geojson = {
              "type": "LineString",
              "coordinates": $this.convertToLonLat(route.coordinates)
            }

            // add route to layergroup
            L.geoJSON(geojson, {
              pane: "routes",
              style: {
                "color": color,
                "weight": 2,
                "opacity": 0.5
              }
            }).addTo(group);

            // add layergroup to management object
            leaflet_data["routes"][name] = group;

            var settings = {
              "show": $this.getStoredSetting("layers-dyn-routes-" + name, false),
              "mode": mode
            };

            $this.$set($this.layers.dyn.routes, name, settings);
          });
        });
      },
      map_fetch_spawns(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.spawns) {
          return;
        }

        axios.get('get_spawns' + urlFilter).then(function (res) {
          res.data.forEach(function (spawn) {
            if (spawn['endtime'] !== null) {
              var endsplit = spawn['endtime'].split(':');
              var endMinute = parseInt(endsplit[0]);
              var endSecond = parseInt(endsplit[1]);
              var despawntime = moment();
              var now = moment();

              if (spawn['spawndef'] == 15) {
                var timeshift = 60;
              } else {
                var timeshift = 30;
              }

              // setting despawn and spawn time
              despawntime.minute(endMinute);
              despawntime.second(endSecond);
              var spawntime = moment(despawntime);
              spawntime.subtract(timeshift, 'm');

              if (despawntime.isBefore(now)) {
                // already despawned. shifting hours
                spawntime.add(1, 'h');
                despawntime.add(1, 'h');
              }

              timeformat = 'YYYY-MM-DD HH:mm:ss';
              if (now.isBetween(spawntime, despawntime)) {
                var color = "green";
              } else if (spawntime.isAfter(now)) {
                var color = "blue";
              }
            } else {
              var color = "red";
            }

            var skip = true;
            if ($this["spawns"][spawn["id"]]) {
              // check if we should update an existing spawn
              if ($this["spawns"][spawn["id"]]["endtime"] === null && spawn["endtime"] !== null) {
                map.removeLayer(leaflet_data["spawns"][spawn["id"]]);
                delete leaflet_data["spawns"][spawn["id"]];
              } else {
                skip = false;
              }
            }

            if (skip) {
              // store spawn meta data
              $this["spawns"][spawn["id"]] = spawn;

              leaflet_data["spawns"][spawn["id"]] = L.circle([spawn['lat'], spawn['lon']], {
                radius: 2,
                color: color,
                fillColor: color,
                weight: 1,
                opacity: 0.7,
                fillOpacity: 0.5,
                id: spawn["id"]
              }).bindPopup($this.build_spawn_popup, { 'className': 'spawnpopup' });

              $this.addMouseEventPopup(leaflet_data["spawns"][spawn["id"]]);

              // only add them if they're set to visible
              if ($this.layers.stat.spawns) {
                leaflet_data["spawns"][spawn["id"]].addTo(map);
              }
            }
          });
        });
      },
      map_fetch_quests(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.quests) {
          return;
        }

        axios.get("get_quests" + urlFilter).then(function (res) {
          res.data.forEach(function (quest) {
            if ($this.quests[quest["pokestop_id"]]) {
              return;
            }

            $this.quests[quest["pokestop_id"]] = quest;

            leaflet_data["quests"][quest["pokestop_id"]] = L.marker([quest['latitude'], quest['longitude']], {
              id: quest["pokestop_id"],
              virtual: true,
              icon: $this.build_quest_small(quest['quest_reward_type_raw'], quest['item_id'], quest['pokemon_id'])
            }).bindPopup($this.build_stop_popup, { "className": "questpopup"});

            $this.addMouseEventPopup(leaflet_data["quests"][quest["pokestop_id"]]);

            if ($this.layers.stat.quests) {
              leaflet_data["quests"][quest["pokestop_id"]].addTo(map);
            }
          });
        });
      },
      map_fetch_geofences() {
        var $this = this;
        axios.get('get_geofence').then(function (res) {
          res.data.forEach(function (geofence) {
            var group = L.layerGroup();

            // meta data for management
            var name = geofence.name;

            if ($this.layers.dyn.geofences[name]) {
              return;
            }

            var geojson = {
              "type": "MultiPolygon",
              "coordinates": geofence.coordinates
            }

            // add geofence to layergroup
            L.geoJSON(geojson, {
              pane: "geofences",
              style: {
                "color": $this.getRandomColor(),
                "weight": 2,
                "opacity": 0.25
              }
            }).addTo(group);

            // add layergroup to management object
            leaflet_data["geofences"][name] = group;

            var settings = {
              "show": $this.getStoredSetting("layers-dyn-geofences-" + name, false),
            };

            $this.$set($this.layers.dyn.geofences, name, settings);
          });
        });
      },
      map_fetch_mons(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.mons) {
          return;
        }

        axios.get('get_map_mons' + urlFilter).then(function (res) {
          res.data.forEach(function (mon) {

            var noskip = true;
            if ($this["mons"][mon["encounter_id"]]) {
              if ($this["mons"][mon["encounter_id"]]["last_modified"] != mon["last_modified"]) {
                map.removeLayer(leaflet_data["mons"][mon["encounter_id"]]);
                delete leaflet_data["mons"][mon["encounter_id"]];
              } else {
                noskip = false;
              }
            }

            if (noskip) {
              // store meta data
              $this["mons"][mon["encounter_id"]] = mon;

              if (leaflet_data["monicons"][mon["mon_id"]]) {
                var icon = leaflet_data["monicons"][mon["mon_id"]];
              } else {
                var form = String.prototype.padStart.call(mon["form"], 2, 0)
                //var image = `asset/pokemon_icons/pokemon_icon_${String.prototype.padStart.call(mon["mon_id"], 3, 0)}_${form}.png`;
                var image = `https://raw.githubusercontent.com/whitewillem/PogoAssets/resized/icons_large/pokemon_icon_${String.prototype.padStart.call(mon["mon_id"], 3, 0)}_${form}.png`;
                var icon = L.icon({
                  iconUrl: image,
                  iconSize: [40, 40],
                });

                leaflet_data["monicons"][mon["mon_id"]] = icon;
              }

              leaflet_data["mons"][mon["encounter_id"]] = L.marker([mon["latitude"], mon["longitude"]], {
                id: mon["encounter_id"],
                virtual: true,
                icon: icon
              }).bindPopup($this.build_mon_popup, { "className": "monpopup" });

              $this.addMouseEventPopup(leaflet_data["mons"][mon["encounter_id"]]);

              // only add them if they're set to visible
              if ($this.layers.stat.mons) {
                leaflet_data["mons"][mon["encounter_id"]].addTo(map);
              }
            }
          });
        });
      },
      changeDynamicLayers(type) {
        for (k in this.layers.dyn[type]) {
          tlayer = this.layers.dyn[type][k];
          this.updateStoredSetting("layers-dyn-"+type+"-" + k, tlayer.show);

          if (tlayer.show == true && !map.hasLayer(leaflet_data[type][k])) {
            map.addLayer(leaflet_data[type][k]);
          } else if (tlayer.show == false && map.hasLayer(leaflet_data[type][k])) {
            map.removeLayer(leaflet_data[type][k]);
          }
        }
      },
      changeStaticLayer(name, oldstate, newState) {
        if (oldstate === true) {
          Object.keys(leaflet_data[name]).forEach(function(key) {
            map.removeLayer(leaflet_data[name][key]);
          });
        } else {
          Object.keys(leaflet_data[name]).forEach(function(key) {
            map.addLayer(leaflet_data[name][key]);
          });
        }

        this.updateStoredSetting("layer-stat-"+name, newState);
      },
      getRandomColor() {
        // generates only dark colors for better contrast
        var letters = '0123456789'.split('');
        var color = '#';
        for (var i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 10)];
        }
        return color;
      },
      build_quest_small(quest_reward_type_raw, quest_item_id, quest_pokemon_id) {
        switch (quest_reward_type_raw) {
          case 2:
            var image = 'static/quest/reward_' + quest_item_id + '_1.png';
            var size = [30, 30]
            var anchor = [30, 20]
            break;
          case 3:
            var image = 'static/quest/reward_stardust.png';
            var size = [30, 30]
            var anchor = [30, 20]
            break;
          case 7:
            var form = '00';
            if (quest_pokemon_id === 327) {
              form = '11';
            }
            var image = 'asset/pokemon_icons/pokemon_icon_' + String.prototype.padStart.call(quest_pokemon_id, 3, 0) + '_' + form + '.png';
            var size = [50, 50]
            var anchor = [40, 30]
            break;
        }

        var icon = L.icon({
          iconUrl: 'static/Pstop-quest.png',
          shadowUrl: image,
          iconSize: [30, 30],
          shadowSize: size,
          shadowAnchor: anchor
        })

        return icon;
      },
      build_quest(quest_reward_type_raw, quest_task, quest_pokemon_id, quest_item_id, quest_item_amount, quest_pokemon_name, quest_item_type) {
        var size = "100%";

        switch (quest_reward_type_raw) {
          case 2:
            var image = `static/quest/reward_${quest_item_id}_1.png`;
            var rewardtext = `${quest_item_amount}x ${quest_item_type}`;
            break;
          case 3:
            var image = "static/quest/reward_stardust.png";
            var rewardtext = `${quest_item_amount} ${quest_item_type}`;
            break;
          case 7:
            var form = '00';
            if (quest_pokemon_id === 327) {
              form = '11';
            }
            var image = `asset/pokemon_icons/pokemon_icon_${String.prototype.padStart.call(quest_pokemon_id, 3, 0)}_${form}.png`;
            var rewardtext = quest_pokemon_name;
            var size = "150%";
            break;
        }

        return `
          <div class="quest">
            <div class="task"><i class="fa fa-question-circle"></i> Task: <strong>${quest_task}</strong></div>
            <div class="reward"><i class="fa fa-trophy"></i> Reward: <strong>${rewardtext}</strong></div>
            <div class="rewardImg" style="background-image: url(${image}); background-size: ${size}"></div>
          </div>`;
      },
      build_stop_popup(marker) {
        var quest = this.quests[marker.options.id];

        return `
          <div class="content">
            <div class="image" style="background: url(${quest["url"]}) center center no-repeat;"></div>
            <div class="name"><strong>${quest["name"]}</strong></div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${quest["pokestop_id"]}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${quest["latitude"]},${quest["longitude"]}">${quest["latitude"]}, ${quest["longitude"]}</a>
            </div>
            <div id="questTimestamp"><i class="fa fa-clock"></i> Scanned: ${moment(quest['timestamp']*1000).format("YYYY-MM-DD HH:mm:ss")}</div>
            <br>
            ${this.build_quest(quest['quest_reward_type_raw'], quest['quest_task'], quest['pokemon_id'], quest['item_id'], quest['item_amount'], quest['pokemon_name'], quest['item_type'])}
          </div>`;
      },
      build_gym_popup(marker) {
        gym = this.gyms[marker.options.id];
        raid = this.raids[marker.options.id];

        raidContent = "";
        if (raid) {
          var monText = "";
          if (raid["mon"]) {
            var mon = String.prototype.padStart.call(raid["mon"], 3, 0);
            var form = String.prototype.padStart.call(raid["form"], 2, 0);
            var image = `asset/pokemon_icons/pokemon_icon_${mon}_${form}.png`;
            var monText = `<div class="monId"><i class="fas fa-ghost"></i> Mon: <strong>#${raid["mon"]}</strong></div>`
          } else {
            switch (raid["level"]) {
              case 1:
              case 2:
                var image = "asset/static_assets/png/ic_raid_egg_normal.png";
                break;
              case 3:
              case 4:
                var image = "asset/static_assets/png/ic_raid_egg_rare.png";
                break;
              case 5:
                var image = "asset/static_assets/png/ic_raid_egg_legendary.png";
                break;
            }
          }

          var levelStars = `<i class="fas fa-star"></i>`.repeat(raid["level"]);

          var now = moment();
          var spawn = moment(raid["spawn"]*1000);
          var start = moment(raid["start"]*1000);
          var end = moment(raid["end"]*1000);

          var activeText = "";
          var endText = "";
          if (now.isAfter(start) && now.isBefore(end)) {
            var activeText = `<span class="text-success">(active <i class="fa fa-ghost"></i>)</span>`;
            var endText = `(${now.to(end)})`;
          } else if (now.isBefore(start)) {
            var activeText = `(${now.to(start)})`;
          } else if (now.isAfter(end)) {
            var endText = `(${end.from(now)})`;
          }

          var raidtimeformat = "HH:mm:ss";
          var raidContent = `
            <br>
            <div class="raid">
              <div class="level"><i class="fas fa-arrow-circle-up"></i> Level: <strong>${levelStars}</strong></div>
              ${monText}
              <div class="hatch"><i class="fa fa-egg"></i> Spawn: <strong>${spawn.format(raidtimeformat)}</strong></div>
              <div class="start"><i class="fa fa-hourglass-start"></i> Start: <strong>${start.format(raidtimeformat)} ${activeText}</strong></div>
              <div class="end"><i class="fas fa-hourglass-end"></i> End: <strong>${end.format(raidtimeformat)} ${endText}</strong></div>
              <div class="monImg" style="background-image: url(${image}); background-size: 100%"></div>
            </div>`;
        }


        var timeformat = "YYYY-MM-DD HH:mm:ss";
        var last_scanned = moment(gym["last_scanned"]*1000);

        return `
          <div class="content">
            <div class="image" style="background: url(${gym["img"]}) center center no-repeat;"></div>
            <div class="name"><strong>${gym["name"]}</strong></div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${gym["id"]}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${gym["lat"]},${gym["lon"]}">${gym["lat"]}, ${gym["lon"]}</a>
           </div>
           <div class="timestamp"><i class="fa fa-clock"></i> Scanned: ${last_scanned.format(timeformat)}</div>
           ${raidContent}
          </div>`;
      },
      build_spawn_popup(marker) {
        spawn = this.spawns[marker.options.id];

        if (spawn['endtime'] !== null) {
          var timeformat = "YYYY-MM-DD HH:mm:ss";

          var endsplit = spawn['endtime'].split(':');
          var endMinute = parseInt(endsplit[0]);
          var endSecond = parseInt(endsplit[1]);
          var despawntime = moment();
          var now = moment();

          if (spawn['spawndef'] == 15) {
            var type = '1h';
            var timeshift = 60;
          } else {
            var type = '30m';
            var timeshift = 30;
          }

          // setting despawn and spawn time
          despawntime.minute(endMinute);
          despawntime.second(endSecond);
          var spawntime = moment(despawntime);
          spawntime.subtract(timeshift, 'm');

          if (despawntime.isBefore(now)) {
            // already despawned. shifting hours
            spawntime.add(1, 'h');
            despawntime.add(1, 'h');
          }

          var activeText = "";
          if (now.isBetween(spawntime, despawntime)) {
            var activeText = `<span class="text-success">(active <i class="fa fa-ghost"></i>)</span>`;
          }

          var spawntiming = `
            <div class="spawn"><i class="fa fa-hourglass-start"></i> Spawn: <strong>${spawntime.format(timeformat)} ${activeText}</strong></div>
            <div class="despawn"><i class="fa fa-hourglass-end"></i> Despawn: <strong>${despawntime.format(timeformat)}</strong></div>`;
        } else {
          var spawntiming = "";
        }

        return `
          <div class="content">
            <div  class="id"><i class="fa fa-fingerprint"></i> <span>${spawn["id"]}</span></div>
            <div class="coords">
              <i class ="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${spawn["lat"]},${spawn["lon"]}">${spawn["lat"].toFixed(6)}, ${spawn["lon"].toFixed(6)}</a>
           </div>
           <div class="timestamp"><i class="fa fa-clock"></i> Scanned: ${spawn["lastscan"]}</div>
           <br>
            <div cla ss="spawnContent">
            <div class="spawnType"><i class="fa fa-wrench"></i> Type: <strong>${type || "Unknown"}</strong> spawnpoint</div>
              <div class="spawnTiming">${spawntiming}</div>
            </div>
          </div>`;
      },
      build_mon_popup(marker) {
        mon = this.mons[marker.options.id];

        var form = String.prototype.padStart.call(mon["form"], 2, 0);
        //var image = `asset/pokemon_icons/pokemon_icon_${monpad}_${formpad}.png`;
        var image = `https://raw.githubusercontent.com/whitewillem/PogoAssets/resized/icons_large/pokemon_icon_${String.prototype.padStart.call(mon["mon_id"], 3, 0)}_${form}.png`;

        var iv = (mon["individual_attack"] + mon["individual_defense"] + mon["individual_stamina"])*100/45;
        var end = moment(mon["disappear_time"]*1000);

        if (iv == 100) {
          var ivcolor = "lime";
        } else if (iv >= 82) {
          var ivcolor =  "green";
        } else if (iv >= 66) {
          var ivcolor =  "olive";
        } else if (iv >= 51) {
          var ivcolor = "orange";
        } else {
          var ivcolor = "red";
        }

        var ivtext = "";
        if (iv !== 0) {
          ivtext = `
              <div class="iv">
                <i class="fas fa-award"></i> IV: <strong style="color: ${ivcolor}">${Math.round(iv * 100) / 100}%</strong>
                (Att: <strong>${mon["individual_attack"]}</strong> | Def: <strong>${mon["individual_defense"]}</strong> | Sta: <strong>${mon["individual_stamina"]}</strong>)
              </div>
              <div class="measurements">
                <i class="fas fa-ruler-vertical"></i> Height: <strong>${mon["height"].toFixed(2)}</strong>
                <i class="fas fa-weight-hanging"></i> Weight: <strong>${mon["weight"].toFixed(2)}</strong>
              </div>
              <br>`;
        }

        return `
          <div class="content">
            <div class="name">#${mon["mon_id"]} ${mon["gender"]==1?'<i class="fas fa-mars"></i>':'<i class="fas fa-venus"></i>'}</div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${mon["encounter_id"]}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${mon["latitude"]},${mon["longitude"]}">${mon["latitude"].toFixed(6)}, ${mon["longitude"].toFixed(6)}</a>
           </div>
            <div id="timestamp"><i class="fa fa-clock"></i> Modified: ${moment(mon['last_modified']*1000).format("YYYY-MM-DD HH:mm:ss")}</div>
            <br>
            ${ivtext}
          <div class="end"><i class="fas fa-hourglass-end"></i> Despawn: <strong>${end.format("YYYY-MM-DD HH:mm:ss")} (${end.from(moment())})</strong></div>
          <div class="monImg" style="background-image: url(${image}); background-size: 100%"></div>
          </div>
        `;
      },
      getStoredSetting(name, defaultval) {
        var val = localStorage.getItem('settings');
        if (val == null) {
          return defaultval;
        }

        var settings = JSON.parse(val);
        if (settings[name] === undefined) {
          return defaultval;
        }

        return settings[name];
      },
      updateStoredSetting(name, value) {
        var settings = {};
        var storedSettings = localStorage.getItem('settings');
        if (storedSettings != null) {
          settings = JSON.parse(storedSettings);
        }

        settings[name] = value;
        localStorage.setItem('settings', JSON.stringify(settings));
      },
      removeStoredSetting(name) {
        var settings = {};
        var storedSettings = localStorage.getItem('settings');
        if (storedSettings != null) {
          settings = JSON.parse(storedSettings);
        }

        delete settings[name];

        localStorage.setItem('settings', JSON.stringify(settings));
      },
      l_event_moveend() {
        var $this = this;
        var center = map.getCenter();
        this.updateStoredSetting('center', center.lat + ',' + center.lng);
        this.updateBounds();

        if (fetchTimeout) {
          clearTimeout(fetchTimeout);
          fetchTimeout = null;
        }

        fetchTimeout = setTimeout(function() {
          $this.map_fetch_everything();
        }, 500);
      },
      l_event_zoomed() {
        var $this = this;
        this.updateStoredSetting('zoomlevel', map.getZoom());
        this.updateBounds();

        // update gym radius dynamically
        Object.keys(leaflet_data["gyms"]).forEach(function(id) {
          leaflet_data["gyms"][id].setRadius(Math.pow((20 - map.getZoom()), 2.5));
        });

        if (fetchTimeout) {
          clearTimeout(fetchTimeout);
          fetchTimeout = null;
        }

        fetchTimeout = setTimeout(function() {
          $this.map_fetch_everything();
        }, 500);
      },
      l_event_click(e) {
        if(clickToScanActive) {
          $('#injectionModal').data('coords', e.latlng.lat + ',' + e.latlng.lng).modal();
        }
      },
      addMouseEventPopup(marker) {
        marker.on("mouseover", function(e) {
          marker.openPopup();
        });

        marker.on("mouseout", function(e) {
          if (!marker.keepPopupOpen) {
            marker.closePopup();
          }
        });

        marker.on("click", function(e) {
          if (!marker.isPopupOpen()) {
            marker.openPopup();
            marker.keepPopupOpen = true;
          } else {
            marker.keepPopupOpen = false;
            marker.closePopup();
          }
        });
      },
      updateBounds(isOld) {
        if (!isOld) {
          var neLat = "neLat";
          var neLon = "neLon";
          var swLat = "swLat";
          var swLon = "swLon";
        } else {
          var neLat = "oNeLat";
          var neLon = "oNeLon";
          var swLat = "oSwLat";
          var swLon = "oSwLon";
        }

        var bounds = map.getBounds();
        this.updateStoredSetting(neLat, bounds.getNorthEast().lat);
        this.updateStoredSetting(neLon, bounds.getNorthEast().lng);
        this.updateStoredSetting(swLat, bounds.getSouthWest().lat);
        this.updateStoredSetting(swLon, bounds.getSouthWest().lng);
      },
      injectLocation() {
        $.ajax({
          type: "GET",
          url: 'send_gps?origin=' + $('#injectionWorker').val() +
            '&coords=' + $('#injectionModal').data('coords') +
            '&sleeptime=' + $('#injectionSleep').val()
        });
      },
      convertToLonLat(coords) {
        lonlat = []
        coords.forEach(function (coord) {
          lonlat.push([coord[1], coord[0]]);
        });
        return lonlat;
      },
      initMap() {
        // get stored settings
        this.settings.maptiles = this.getStoredSetting("settings-maptiles", "cartodblight");
        this.settings.routes.coordinateRadius.raids = this.getStoredSetting('settings-coordinateRadius-raids', 490);
        this.settings.routes.coordinateRadius.quests = this.getStoredSetting('settings-coordinateRadius-quests', 40);
        this.settings.routes.coordinateRadius.mons = this.getStoredSetting('settings-coordinateRadius-mons', 67);
        for (index of Object.keys(this.layers.stat)) {
          this.layers.stat[index] = this.getStoredSetting("layer-stat-"+index, false);
        }

        // magic thingy to prevent double-loading data
        // after we initially restored settings
        // from stored settings
        this.$nextTick(function() {
          init = false;
        });

        // get stored center and zoom level if they exists
        const storedZoom = this.getStoredSetting('zoomlevel', 3);
        const storedCenter = this.getStoredSetting('center', '52.521374,13.411201');
        leaflet_data.tileLayer = L.tileLayer(this.maptiles[this.settings.maptiles].url);

        map = L.map('map', {
          layers: [leaflet_data.tileLayer],
          zoomControl: false,
          updateWhenZooming: false,
          updateWhenIdle: true,
          preferCanvas: true
        }).setView(storedCenter.split(','), storedZoom);

        // add custom button
        locInjectBtn.addTo(map);

        // extra panes to make sure routes and
        // geofences are below everything else
        map.createPane("geofences");
        map.createPane("routes");

        // move zoom controls
        L.control.zoom({
          position: 'bottomright'
        }).addTo(map);

        // add sidebar
        sidebar = L.control.sidebar({
          autopan: false,
          closeButton: true,
          container: "sidebar",
          position: "left",
        }).addTo(map);

        sidebar.close();

        {% if setlat and setlng %}
        var setlat = {{ setlat }};
        var setlng = {{ setlng }};

        if(setlat != 0 && setlng != 0) {
            var circle = L.circle([setlat, setlng], {
            color: 'blue',
            fillColor: 'blue',
            fillOpacity: 0.5,
            radius: 30
          }).addTo(map);

          map.setView([setlat, setlng], 20);
        };
        {% endif %}

        map.on('zoomend', this.l_event_zoomed);
        map.on('moveend', this.l_event_moveend);
        map.on('click', this.l_event_click);
        map.on('mousedown', function() {
          sidebar.close();
        });
      },
      buildUrlFilter(force = false) {
        var oSwLat = this.getStoredSetting("oSwLat", null);
        var oSwLon = this.getStoredSetting("oSwLon", null);
        var oNeLat = this.getStoredSetting("oNeLat", null);
        var oNeLon = this.getStoredSetting("oNeLon", null);

        var old = {};
        if (oSwLat && oSwLon && oNeLat && oNeLon && !force) {
          old = {
            "oSwLat": oSwLat,
            "oSwLon": oSwLon,
            "oNeLat": oNeLat,
            "oNeLon": oNeLon
          };
        }

        var timestamp = this.getStoredSetting("fetchTimestamp", null);
        if (timestamp && !force) {
          old["timestamp"] = timestamp;
        }

        var swLat = this.getStoredSetting("swLat", null);
        var swLon = this.getStoredSetting("swLon", null);
        var neLat = this.getStoredSetting("neLat", null);
        var neLon = this.getStoredSetting("neLon", null);

        var bounds = {
          "swLat": swLat,
          "swLon": swLon,
          "neLat": neLat,
          "neLon": neLon
        };

        Object.keys(old).forEach(function(key) { bounds[key] = old[key]; });
        var querystring = new URLSearchParams(bounds).toString();

        // temp: update last update timestamp
        this.updateStoredSetting("fetchTimestamp", Math.floor(Date.now() / 1000))

        return "?" + querystring;
      }
    }
  });
</script>
{% endblock %}

{% block content %}
<div id="app">
  <div id="sidebar" class="leaflet-sidebar">
    <div class="leaflet-sidebar-tabs">
      <ul role="tablist">
        <li><a href="#points" role="tab"><i class="fa fa-map-marker"></i></a></li>
        <li><a href="#routes" role="tab"><i class="fa fa-route"></i></a></li>
        <li><a href="#geofences" role="tab"><i class="fa fa-draw-polygon"></i></a></li>
        <li><a href="#settings" role="tab"><i class="fa fa-cog"></i></a></li>
      </ul>
    </div>

    <div class="leaflet-sidebar-content">
      <div class="leaflet-sidebar-pane" id="points">
        <h1 class="leaflet-sidebar-header bg-dark">Points<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <div class="sidebar-pane-content">
          <ul class="list-group list-group-flush">
            {% raw %}
            <li v-for="(item, index) in layers.stat" class="list-group-item layer-item d-flex">
              <div class="flex-grow-1">{{ index }}</div>
              <div class="custom-control custom-switch">
                <input :id="'layers-stat-'+index" type="checkbox" v-model="layers.stat[index]" class="custom-control-input" />
                <label :for="'layers-stat-'+index" class="custom-control-label"></label>
              </div>
            </li>
            {% endraw %}
          </ul>
        </div>
      </div>

      <div class="leaflet-sidebar-pane" id="routes">
        <h1 class="leaflet-sidebar-header bg-dark">Routes<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <div class="sidebar-pane-content">
          <ul class="list-group list-group-flush">
            {% raw %}
            <li v-for="(route, index) in layers.dyn.routes" class="list-group-item layer-item justify-content-between d-flex align-items-center">
              <div class="flex-grow-1">{{ index }}</div>
              <span class="badge badge-secondary" style="margin-right: 5px;">{{ route.mode }}</span>
              <div class="custom-control custom-switch">
                <input :id="'layers-dyn-routes-'+index" type="checkbox" v-model="layers.dyn.routes[index].show" class="custom-control-input" />
                <label :for="'layers-dyn-routes-'+index" class="custom-control-label"></label>
              </div>
            </li>
            {% endraw %}
          </ul>
        </div>
      </div>

      <div class="leaflet-sidebar-pane" id="geofences">
        <h1 class="leaflet-sidebar-header bg-dark">Geofences<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <div class="sidebar-pane-content">
          <ul class="list-group list-group-flush">
            {% raw %}
            <li v-for="(fence, index) in layers.dyn.geofences" class="list-group-item layer-item d-flex">
              <div class="flex-grow-1">{{ index }}</div>
              <div class="custom-control custom-switch">
                <input :id="'layers-dyn-geofences-'+index" type="checkbox" v-model="layers.dyn.geofences[index].show" class="custom-control-input" />
                <label :for="'layers-dyn-geofences-'+index" class="custom-control-label"></label>
              </div>
            </li>
            {% endraw %}
          </ul>
        </div>
      </div>

      <div class="leaflet-sidebar-pane" id="settings">
        <h1 class="leaflet-sidebar-header bg-dark">Settings<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <div class="sidebar-pane-content">
          <ul class="list-group list-group-flush">
            <li class="list-group-item layer-item d-flex">
              <div class="flex-grow-1"><strong>Raids visual radius</strong></div>
              <div class="custom-control custom-switch">
                <input id="raidcoordinateradius" type="number" v-model="settings.routes.coordinateRadius.raids" max="1100" class="form-control form-control-sm" />
              </div>
            </li>
            <li class="list-group-item layer-item d-flex">
              <div class="flex-grow-1"><strong>Mons visual radius</strong></div>
              <div class="custom-control custom-switch">
                <input id="moncoordinateradius" type="number" v-model="settings.routes.coordinateRadius.mons" max="1100" class="form-control form-control-sm" />
              </div>
            </li>
            <li class="list-group-item layer-item d-flex">
              <div class="flex-grow-1"><strong>Quests visual radius</strong></div>
              <div class="custom-control custom-switch">
                <input id="questcoordinateradius" type="number" v-model="settings.routes.coordinateRadius.quests" max="1100" class="form-control form-control-sm" />
              </div>
            </li>
            <li class="list-group-item layer-item d-flex">
              <div class="flex-grow-1"><strong>Map tiles</strong></div>
              <div class="form-group">
                {% raw %}
                <select class="form-control form-control-sm" v-model="settings.maptiles">
                  <option v-for="(maptile, index) in maptiles" v-bind:value="index">{{ maptile.name }}</option>
                </select>
                {% endraw %}
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="injectionModal" tabindex="-1" role="dialog" aria-labelledby="injectionModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="injectionModalLabel">Inject Location</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>

        <div class="modal-body">
          <p>Would you like to send a scanner to update this location?</p>
          <select id="injectionWorker" class="form-control">
            {% raw %}
            <option v-for="worker in workers">
              {{ worker.name }}
            </option>
            {% endraw %}
          </select>

          <p>Extra sleep time (in seconds, optional):</p>
          <input type="number" class="form-control" id="injectionSleep" value="0">
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">No</button>
          <button type="button" class="btn btn-primary" v-on:click="injectLocation" data-dismiss="modal">Yes</button>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>
</div>
{% endblock %}
