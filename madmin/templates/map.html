{% extends "base.html" %}

{% block header %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin="" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/css/leaflet-sidebar.min.css" />
<link rel="stylesheet" href="static/style/madmin.css" />
{% endblock %}

{% block scripts %}
<script src="https://vuejs.org/js/vue.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://use.fontawesome.com/releases/v5.6.3/js/all.js" integrity="sha384-EIHISlAOj4zgYieurP0SdoiBYfGJKkgWedPHH4jCzpCXLmzVsw1ouK59MuUtP4a1" crossorigin="anonymous" defer></script>
<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/js/leaflet-sidebar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"></script>
<script>
var map = null;
var leaflet_data = {};

new Vue({
	el: '#app',
	data: {
		layers: {},
		coordinates: {
			gyms: null,
			route: {
				raid: null,
				mon: null
			}
		},
		settings: {
			routes: {
				coordinateRadius: {
					raid: 490,
					mon: 67
				}
			}
		}
	},
	watch: {
		layers: {
			deep: true,
			handler: function() {
				for (k in this.layers) {
					tlayer = this.layers[k];

					if (tlayer.show == true && !map.hasLayer(leaflet_data[k])) {
						map.addLayer(leaflet_data[k]);
					} else if (tlayer.show == false && map.hasLayer(leaflet_data[k])) {
						map.removeLayer(leaflet_data[k]);
					}
				}
			}
		},
		'settings.routes.coordinateRadius': {
			deep: true,
			handler: function() {
				for (routetype in this.settings.routes.coordinateRadius) {
					this.coordinates.route[routetype].forEach(function(route) {
						this.setCircleRadiusForRoute(route, routetype);
					}, this);
				}
			}
		}
	},
	mounted() {
		// init our map first
		this.initMap();

		// get vue object into here
		var $this = this;

		// retrieve gyms
		axios.get('/get_gymcoords').then(function(res) {
			var l_gyms = L.layerGroup();

			res.data.forEach(function(gym) {
				L.marker([gym['lat'], gym['lon']], { icon: $this.gymicon(gym['team_id'])})
					.bindPopup('<div id="gymImage" style="background: url(&quot;'+gym['img']+'&quot;) center center no-repeat;"></div><div id="gymName"><strong>'+gym['name']+'</div><div id="gymID"></strong>'+gym['id']+'</div><div id="gymCoords"><a href="https://maps.google.com/?q='+gym['lat']+','+gym['lon']+'">'+gym['lat']+', '+gym['lon']+'</a></div>',
						{ 'className': 'gympopup' })
					.addTo(l_gyms);
			});

			// add layer to map
			$this.addLayer("gyms", l_gyms, false);
		});

		// retrieve routes
		axios.get('/get_route').then(function(res) {
			var dataprop = ""
			var l_routes = L.featureGroup();

			res.data.forEach(function(route) {
				var group = L.layerGroup();
				var coords = [];

				if (route.mode == "mon_mitm") {
					mode = "mon";
					cradius = $this.settings.routes.coordinateRadius.mon;
				} else {
					mode = "raid";
					cradius = $this.settings.routes.coordinateRadius.raid;
				}

				route.coordinates.forEach(function(coord) {
					circle = L.circle(coord, {
						radius: cradius,
						color: "#9C3744",
						fillColor: "#F4556A",
						fillOpacity: 1,
						weight: 1,
						opacity: 0.2,
						fillOpacity: 0.1
					});

					circle.addTo(group);
					coords.push(circle);
				});

				// add these coordinates to our global list
				//that.coordinates.route[mode].push(coords);

				var geojson = {
					"type": "LineString",
					"coordinates": $this.convertToLonLat(route.coordinates)
				}

				// add route to layergroup
				L.geoJSON(geojson, { style: { "color": "#FF0000", "weight": 2, "opacity": 0.5 } }).addTo(group);
				// add layer group to routes featureGroup
				group.addTo(l_routes);

				$this.addLayer("routes", l_routes, true);
			});
		});

		axios.get('/get_spawns').then(function(res) {
			var l_spawns = L.layerGroup();

			res.data.forEach(function(spawn) {
				if (spawn['endtime'] !== null) {
					var markertext = '<strong class="text-success">Known end time</strong><br>'
					var endsplit = spawn['endtime'].split(':');
					var endMinute = parseInt(endsplit[0]);
					var endSecond = parseInt(endsplit[1]);
					var despawntime = moment();
					var now = moment();

					if (spawn['spawndef'] == 15) {
						markertext += '<br>Type: 1h spawn<br>';
						var timeshift = 60;
					} else {
						markertext += '<br>Type: 30m spawn<br>';
						var timeshift = 30;
					}

					// setting despawn and spawn time
					despawntime.minute(endMinute);
					despawntime.second(endSecond);
					var spawntime = moment(despawntime);
					spawntime.subtract(timeshift, 'm');

					if (despawntime.isBefore(now)) {
						// already despawned. shifting hours
						spawntime.add(1, 'h');
						despawntime.add(1, 'h');
					}

					timeformat = 'YYYY-MM-DD HH:mm:ss';
					if (now.isBetween(spawntime, despawntime)) {
						markertext += "<br><strong>SPAWN ACTIVE</strong>"
						markertext += "<br>Spawned at: " + spawntime.format(timeformat);
						markertext += "<br>Despawns at: " + despawntime.format(timeformat);
						overlaytext = 'Despawn ' + despawntime.fromNow();
						var color = "green";
					} else if (spawntime.isAfter(now)) {
						markertext += "<br>Spawns at: " + spawntime.format(timeformat);
						markertext += "<br>Despawns at: " + despawntime.format(timeformat);
						overlaytext = 'Spawn ' + spawntime.fromNow();
						var color = "blue";
					}
				} else {
					var markertext = '<strong class="text-danger">Unknown end time</strong><br>';
					var color = "red";
				}

				L.circle([spawn['lat'], spawn['lon']], {
					radius: 2,
					color: color,
					fillColor: color,
					weight: 1,
					opacity: 0.7,
					fillOpacity: 0.5
				}).addTo(l_spawns)
					.bindPopup(markertext + '<br><br><a href="https://maps.google.com/?q=' + spawn['lat'] + ',' + spawn['lon'] + '">' + spawn['lat'] + ', ' + spawn['lon'] + '</a>',{'className': 'gympopup'})
			});

			$this.addLayer("spawns", l_spawns, false);
		});
	},
	methods: {
		// add a new layer
		addLayer(name, data, show) {
			var lobj = {"show": show};
			leaflet_data[name] = data;
			this.$set(this.layers, name, lobj);
		},
		// event handler if the map has been dragged/moved
		l_event_moveend() {
			var center = map.getCenter();
			localStorage.setItem('center', center.lat+','+center.lng);
		},
		// event handler if the map has been zoomed
		l_event_zoomed() {
			localStorage.setItem('zoomlevel', map.getZoom());
		},
		// convert lat/lng to lng/lat
		convertToLonLat(coords) {
			lonlat = []
			coords.forEach(function(coord) {
				lonlat.push([coord[1], coord[0]]);
			});
			return lonlat;
		},
		// set a circle marker's radius
		setCircleRadiusForRoute(route, type) {
			route.forEach(function(circle) {
				circle.setRadius(this.settings.routes.coordinateRadius[type]);
			}, this);
		},
		// return a gym icon based on a team
		gymicon(team) {
			return L.icon({
				iconUrl: 'static/gym_' + team + '.png',
				iconSize: [32, 32]
			});
		},
		// generate the map
		initMap() {
			// get stored center and zoom level if they exists
			const storedZoom = localStorage.getItem('zoomlevel') || 13;
			const storedCenter = localStorage.getItem('center') || '52.521374,13.411201';
			const layer = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png');

			map = L.map('map', { layers: [layer], zoomControl: false}).setView(storedCenter.split(','), storedZoom);

			L.control.sidebar({
				autopan: false,
				closeButton: true,
				container: "sidebar",
				position: "left",
			}).addTo(map);

			map.on('zoomend', this.l_event_zoomed);
			map.on('moveend', this.l_event_moveend);
		}
	}
});
</script>
{% endblock %}

{% block content %}
<div id="app">
	<div id="sidebar" class="leaflet-sidebar collapsed">
			<div class="leaflet-sidebar-tabs">
				<ul role="tablist">
					<li><a href="#home" role="tab"><i class="fa fa-home"></i></a></li>
				</ul>
			</div>

			<div class="leaflet-sidebar-content">
				<div class="leaflet-sidebar-pane" id="home">
					<h1 class="leaflet-sidebar-header">Settings<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
					<ul class="list-group list-group-flush">
						{% raw %}
							<li v-for="(item, index) in layers" class="list-group-item">
								<strong>{{ index }}</strong>
								<div class="material-switch float-right">
									<input :id="index" type="checkbox" v-model="item.show" />
									<label :for="index" class="badge-primary"></label>
								</div>
							</li>
						{% endraw %}
					</ul>
				</div>
			</div>
	</div>
	<div id="map"></div>
</div>
{% endblock %}
