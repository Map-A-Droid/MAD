{% extends "base.html" %}

{% block header %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin="" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/css/leaflet-sidebar.min.css" />
<link rel="stylesheet" href="static/style/madmin.css?1557406998" />
{% endblock %}

{% block scripts %}
<script src="https://use.fontawesome.com/releases/v5.6.3/js/all.js" integrity="sha384-EIHISlAOj4zgYieurP0SdoiBYfGJKkgWedPHH4jCzpCXLmzVsw1ouK59MuUtP4a1" crossorigin="anonymous" defer></script>
<script src="https://vuejs.org/js/vue.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-sidebar-v2@3.0.6/js/leaflet-sidebar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"></script>
<script>
  L.Marker.addInitHook(function() {
    if (this.options.virtual) {
      this.on('add', function() {
        this._updateIconVisibility = function() {
          if (!this._map) {
            return;
          }
          var map = this._map;
          var isVisible = map.getBounds().contains(this.getLatLng());
          var wasVisible = this._wasVisible;
          var icon = this._icon;
          var iconParent = this._iconParent;
          var shadow = this._shadow;
          var shadowParent = this._shadowParent;

          if (!iconParent) {
            iconParent = this._iconParent = icon.parentNode;
          }
          if (shadow && !shadowParent) {
            shadowParent = this._shadowParent = shadow.parentNode;
          }

          if (isVisible != wasVisible) {
            if (isVisible) {
              iconParent.appendChild(icon);
              if (shadow) {
                shadowParent.appendChild(shadow);
              }
            } else {
              iconParent.removeChild(icon);
              if (shadow) {
                shadowParent.removeChild(shadow);
              }
            }

            this._wasVisible = isVisible;

          }
        };

        this._map.on('resize moveend zoomend', this._updateIconVisibility, this);
        this._updateIconVisibility();

      }, this);
    }
  });

  // main map element
  var map;
  var mapclick = 0;

  // special canvas icon layer
  var mapIconLayer;

  // object to hold all the markers and elements
  var leaflet_data = {
    raids: {},
    spawns: {},
    quests: {},
    gyms: {},
    routes: {},
    geofences: {},
    workers: {}
  };

  Vue.config.devtools = true;

  new Vue({
    el: '#app',
    data: {
      raids: {},
      gyms: {},
      quests: {},
      spawns: {},
      layers: {
        stat: {
          spawns: false,
          gyms: false,
          quests: false,
          workers: false
        },
        dyn: {
          routes: {},
          geofences: {}
        }
      },
      workers: {},
      settings: {
        routes: {
          coordinateRadius: {
            raids: 490,
            quests: 40,
            mons: 67
          }
        }
      }
    },
    watch: {
      "layers.stat.gyms": function(newVal, oldVal) {
        if (newVal) {
          this.map_fetch_gyms(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("gyms", oldVal, newVal);
      },
      "layers.stat.spawns": function(newVal, oldVal) {
        if (newVal) {
          this.map_fetch_spawns(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("spawns", oldVal, newVal);
      },
      "layers.stat.workers": function(newVal, oldVal) {
        if (newVal) {
          this.map_fetch_workers(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("workers", oldVal, newVal);
      },
      "layers.stat.quests": function(newVal, oldVal) {
        if (newVal) {
          this.map_fetch_quests(this.buildUrlFilter(true));
        }

        this.changeStaticLayer("quests", oldVal, newVal);
      },
      "layers.dyn.geofences": {
        deep: true,
        handler: function() {
          this.changeDynamicLayers("geofences");
        }
      },
      "layers.dyn.routes": {
        deep: true,
        handler: function() {
          this.changeDynamicLayers("routes");
        }
      },
      'settings.routes.coordinateRadius': {
        deep: true,
        handler: function () {
          $this = this;
          for (routetype in this.settings.routes.coordinateRadius) {
            this.updateStoredSetting('settings-coordinateRadius-' + routetype, this.settings.routes.coordinateRadius[routetype]);
          }

          for (route in leaflet_data["routes"]) {
            leaflet_data["routes"][route].eachLayer(function(marker) {
              try {
                marker.setRadius($this.settings.routes.coordinateRadius[$this.layers.dyn.routes[route].mode]);
              } catch(e) {
                // routes have a special layer containing polylines
                // unfortunately, there's no identifer for them, thus
                // we catch this exception and ignore it
              }
            });
          }
        }
      }
    },
    mounted() {
      // reset some vars
      this.removeStoredSetting("fetchTimestamp");
      this.removeStoredSetting("oSwLat");
      this.removeStoredSetting("oSwLon");
      this.removeStoredSetting("oNeLat");
      this.removeStoredSetting("oNeLon");

      // init our map first
      this.initMap();

      // initial load
      this.map_fetch_everything();

      // frequently fetch updated data
      setInterval(this.map_fetch_everything, 6000);
    },
    methods: {
      map_fetch_everything() {
        urlFilter = this.buildUrlFilter();

        this.map_fetch_workers();
        this.map_fetch_gyms(urlFilter);
        this.map_fetch_routes();
        this.map_fetch_geofences();
        this.map_fetch_spawns(urlFilter);
        this.map_fetch_quests(urlFilter);

        this.updateBounds(true);
      },
      map_fetch_workers() {
        var $this = this;

        axios.get("get_position").then(function (res) {
          res.data.forEach(function (worker) {
            var name = worker["name"];

            if ($this["workers"][name]) {
              leaflet_data["workers"][name].setLatLng([worker["lat"], worker["lon"]]);
            } else {
              $this.workers[name] = worker;

              leaflet_data["workers"][name] = L.circleMarker([worker['lat'], worker['lon']], {
                radius: 7,
                color: '#E612CB',
                fillColor: '#E612CB',
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.9
              }).bindPopup(name);

              if ($this.layers.stat.workers) {
                leaflet_data["workers"][worker["name"]].addTo(map);
              }
            }
          });
        });
      },
      map_fetch_gyms(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.gyms) {
          return;
        }

        axios.get('get_gymcoords' + urlFilter).then(function (res) {
          res.data.forEach(function (gym) {
            switch (gym['team_id']) {
              default:
                color = '#888';
                break;
              case 1:
                color = '#0C6DFF';
                break;
              case 2:
                color = '#FC0016';
                break;
              case 3:
                color = '#FD830E';
                break;
            }

            var skip = true;
            if ($this["gyms"][gym["id"]]) {
              // check if we should update an existing gym
              if ($this["gyms"][gym["id"]]["team_id"] != gym["team_id"]) {
                map.removeLayer(leaflet_data["gyms"][gym["id"]]);
                delete leaflet_data["gyms"][gym["id"]];
              } else {
                skip = false;
              }
            }

            if (skip) {
              // store gym meta data
              $this["gyms"][gym["id"]] = gym;

              leaflet_data["gyms"][gym["id"]] = L.circle([gym['lat'], gym['lon']], {
                id: gym["id"],
                radius: Math.pow((20 - map.getZoom()), 2.5),
                color: color,
                fillColor: color,
                weight: 2,
                opacity: 1.0,
                fillOpacity: 0.8,
              }).bindPopup($this.build_gym_popup, { 'className': 'gympopup'});

              // only add them if they're set to visible
              if ($this.layers.stat.gyms) {
                leaflet_data["gyms"][gym["id"]].addTo(map);
              }
            }

            if ($this["raids"][gym["id"]]) {
              /// TODO remove past raids
              // end time is different -> new raid
              if ($this["raids"][gym["id"]]["end"] != gym["raid"]["end"]) {
                delete leaflet_data["raids"][gym["id"]];
              }
            }

            if (gym["raid"] != null) {
              $this["raids"][gym["id"]] = gym["raid"];

              switch (gym["raid"]["level"]) {
                case 1:
                case 2:
                  raidcolor = "#FF46F3";
                  break;
                case 3:
                case 4:
                  raidcolor = "#F0B87C";
                  break;
                case 5:
                  raidcolor = "#222222";
                  break;
              }

              leaflet_data["raids"][gym["id"]] = L.circle([gym["lat"], gym["lon"]], {
                id: gym["id"],
                radius: 14,
                color: raidcolor,
                weight: 3,
                opacity: 0.9,
                fillOpacity: 0.0
              });
            }
          });
        });
      },
      map_fetch_routes() {
        var $this = this;

        axios.get("get_route").then(function (res) {
          res.data.forEach(function (route) {
            var group = L.layerGroup();
            var coords = [];

            var name = route.name;
            var color = $this.getRandomColor();

            if ($this.layers.dyn.routes[name]) {
              return;
            }

            if (route.mode == "mon_mitm") {
              mode = "mons";
              cradius = $this.settings.routes.coordinateRadius.mons;
            } else if (route.mode == "pokestops") {
              mode = "quests";
              cradius = $this.settings.routes.coordinateRadius.quests;
            } else if (route.mode == "raids_mitm" || route.mode == "raids_ocr") {
              mode = "raids";
              cradius = $this.settings.routes.coordinateRadius.raids;
            }

            route.coordinates.forEach(function (coord) {
              circle = L.circle(coord, {
                radius: cradius,
                color: color,
                fillColor: color,
                fillOpacity: 1,
                weight: 1,
                opacity: 0.4,
                fillOpacity: 0.1
              });

              circle.addTo(group);
              coords.push(circle);
            });

            var geojson = {
              "type": "LineString",
              "coordinates": $this.convertToLonLat(route.coordinates)
            }

            // add route to layergroup
            L.geoJSON(geojson, { style: { "color": color, "weight": 2, "opacity": 0.5 } }).addTo(group);

            // add layergroup to management object
            leaflet_data["routes"][name] = group;

            var settings = {
              "show": $this.getStoredSetting("layers-dyn-routes-" + name, false),
              "mode": mode
            };

            $this.$set($this.layers.dyn.routes, name, settings);
          });
        });
      },
      map_fetch_spawns(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.spawns) {
          return;
        }

        axios.get('get_spawns' + urlFilter).then(function (res) {
          res.data.forEach(function (spawn) {
            if (spawn['endtime'] !== null) {
              var endsplit = spawn['endtime'].split(':');
              var endMinute = parseInt(endsplit[0]);
              var endSecond = parseInt(endsplit[1]);
              var despawntime = moment();
              var now = moment();

              if (spawn['spawndef'] == 15) {
                var timeshift = 60;
              } else {
                var timeshift = 30;
              }

              // setting despawn and spawn time
              despawntime.minute(endMinute);
              despawntime.second(endSecond);
              var spawntime = moment(despawntime);
              spawntime.subtract(timeshift, 'm');

              if (despawntime.isBefore(now)) {
                // already despawned. shifting hours
                spawntime.add(1, 'h');
                despawntime.add(1, 'h');
              }

              timeformat = 'YYYY-MM-DD HH:mm:ss';
              if (now.isBetween(spawntime, despawntime)) {
                var color = "green";
              } else if (spawntime.isAfter(now)) {
                var color = "blue";
              }
            } else {
              var color = "red";
            }

            var skip = true;
            if ($this["spawns"][spawn["id"]]) {
              // check if we should update an existing spawn
              if ($this["spawns"][spawn["id"]]["endtime"] === null && spawn["endtime"] !== null) {
                map.removeLayer(leaflet_data["spawns"][spawn["id"]]);
                delete leaflet_data["spawns"][spawn["id"]];
              } else {
                skip = false;
              }
            }

            if (skip) {
              // store spawn meta data
              $this["spawns"][spawn["id"]] = spawn;

              leaflet_data["spawns"][spawn["id"]] = L.circle([spawn['lat'], spawn['lon']], {
                radius: 2,
                color: color,
                fillColor: color,
                weight: 1,
                opacity: 0.7,
                fillOpacity: 0.5,
                id: spawn["id"]
              }).bindPopup($this.build_spawn_popup, { 'className': 'spawnpopup' });

              // only add them if they're set to visible
              if ($this.layers.stat.spawns) {
                leaflet_data["spawns"][spawn["id"]].addTo(map);
              }
            }
          });
        });
      },
      map_fetch_quests(urlFilter) {
        var $this = this;

        if (!$this.layers.stat.quests) {
          return;
        }

        axios.get("get_quests" + urlFilter).then(function (res) {
          res.data.forEach(function (quest) {
            if ($this.quests[quest["pokestop_id"]]) {
              return;
            }

            $this.quests[quest["pokestop_id"]] = quest;

            leaflet_data["quests"][quest["pokestop_id"]] = L.marker([quest['latitude'], quest['longitude']], {
              id: quest["pokestop_id"],
              virtual: true,
              icon: $this.build_quest_small(quest['quest_reward_type_raw'], quest['item_id'], quest['pokemon_id'])
            }).bindPopup($this.build_stop_popup, { "className": "questpopup"});

            if ($this.layers.stat.quests) {
              leaflet_data["quests"][quest["pokestop_id"]].addTo(map);
            }
          });
        });
      },
      map_fetch_geofences() {
        var $this = this;
        axios.get('get_geofence').then(function (res) {
          res.data.forEach(function (geofence) {
            var group = L.layerGroup();

            // meta data for management
            var name = geofence.name;

            if ($this.layers.dyn.geofences[name]) {
              return;
            }

            var geojson = {
              "type": "MultiPolygon",
              "coordinates": geofence.coordinates
            }

            // add geofence to layergroup
            L.geoJSON(geojson, { style: { "color": $this.getRandomColor(), "weight": 2, "opacity": 0.25 } }).addTo(group);

            // add layergroup to management object
            leaflet_data["geofences"][name] = group;

            var settings = {
              "show": $this.getStoredSetting("layers-dyn-geofences-" + name, false),
            };

            $this.$set($this.layers.dyn.geofences, name, settings);
          });
        });
      },
      changeDynamicLayers(type) {
        for (k in this.layers.dyn[type]) {
          tlayer = this.layers.dyn[type][k];
          this.updateStoredSetting("layers-dyn-"+type+"-" + k, tlayer.show);

          if (tlayer.show == true && !map.hasLayer(leaflet_data[type][k])) {
            map.addLayer(leaflet_data[type][k]);
          } else if (tlayer.show == false && map.hasLayer(leaflet_data[type][k])) {
            map.removeLayer(leaflet_data[type][k]);
          }
        }
      },
      changeStaticLayer(name, oldstate, newState) {
        if (oldstate === true) {
          Object.keys(leaflet_data[name]).forEach(function(key) {
            map.removeLayer(leaflet_data[name][key]);
          });
        } else {
          Object.keys(leaflet_data[name]).forEach(function(key) {
            map.addLayer(leaflet_data[name][key]);
          });
        }

        this.updateStoredSetting("layer-stat-"+name, newState);
      },
      getRandomColor() {
        // generates only dark colors for better contrast
        var letters = '0123456789'.split('');
        var color = '#';
        for (var i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 10)];
        }
        return color;
      },
      build_quest_small(quest_reward_type_raw, quest_item_id, quest_pokemon_id) {
        switch (quest_reward_type_raw) {
          case 2:
            var image = 'static/quest/reward_' + quest_item_id + '_1.png';
            var size = [30, 30]
            var anchor = [30, 20]
            break;
          case 3:
            var image = 'static/quest/reward_stardust.png';
            var size = [30, 30]
            var anchor = [30, 20]
            break;
          case 7:
            var form = '00';
            if (quest_pokemon_id === 327) {
              form = '11';
            }
            var image = 'asset/pokemon_icons/pokemon_icon_' + String.prototype.padStart.call(quest_pokemon_id, 3, 0) + '_' + form + '.png';
            var size = [50, 50]
            var anchor = [40, 30]
            break;
        }

        var icon = L.icon({
          iconUrl: 'static/Pstop-quest.png',
          shadowUrl: image,
          iconSize: [30, 30],
          shadowSize: size,
          shadowAnchor: anchor
        })

        return icon;
      },
      build_quest(quest_reward_type_raw, quest_task, quest_pokemon_id, quest_item_id, quest_item_amount, quest_pokemon_name, quest_item_type) {
        var size = "100%";

        switch (quest_reward_type_raw) {
          case 2:
            var image = `static/quest/reward_${quest_item_id}_1.png`;
            var rewardtext = `${quest_item_amount}x ${quest_item_type}`;
            break;
          case 3:
            var image = "static/quest/reward_stardust.png";
            var rewardtext = `${quest_item_amount} ${quest_item_type}`;
            break;
          case 7:
            var form = '00';
            if (quest_pokemon_id === 327) {
              form = '11';
            }
            var image = `asset/pokemon_icons/pokemon_icon_${String.prototype.padStart.call(quest_pokemon_id, 3, 0)}_${form}.png`;
            var rewardtext = quest_pokemon_name;
            var size = "150%";
            break;
        }

        return `<div class="quest">
            <div class="task"><i class="fa fa-question-circle"></i> Task: <strong>${quest_task}</strong></div>
            <div class="reward"><i class="fa fa-trophy"></i> Reward: <strong>${rewardtext}</strong></div>
            <div class="rewardImg" style="background-image: url(${image}); background-size: ${size}"></div>
          </div>`;
      },
      build_stop_popup(marker) {
        var quest = this.quests[marker.options.id];

        return `<div class="content">
            <div class="image" style="background: url(${quest['url']}) center center no-repeat;"></div>
            <div class="name"><strong>${quest['name']}</strong></div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${quest['pokestop_id']}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${quest['latitude']},${quest['longitude']}">${quest['latitude']}, ${quest['longitude']}</a>
            </div>
            <div id="questTimestamp"><i class="fa fa-clock"></i> Scanned: ${new Date(quest['timestamp']*1000).toLocaleString()}</div>
            <br>
            ${this.build_quest(quest['quest_reward_type_raw'], quest['quest_task'], quest['pokemon_id'], quest['item_id'], quest['item_amount'], quest['pokemon_name'], quest['item_type'])}
          </div>`;
      },
      build_gym_popup(marker) {
        gym = this.gyms[marker.options.id];

        return `<div class="content">
            <div class="image" style="background: url(${gym['img']}) center center no-repeat;"></div>
            <div class="name"><strong>${gym['name']}</strong></div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${gym['id']}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${gym['lat']},${gym['lon']}">${gym['lat']}, ${gym['lon']}</a>
           </div>
          </div>`;
      },
      build_spawn_popup(marker) {
        spawn = this.spawns[marker.options.id];


        if (spawn['endtime'] !== null) {
          var timeformat = 'YYYY-MM-DD HH:mm:ss';

          var endsplit = spawn['endtime'].split(':');
          var endMinute = parseInt(endsplit[0]);
          var endSecond = parseInt(endsplit[1]);
          var despawntime = moment();
          var now = moment();

          if (spawn['spawndef'] == 15) {
            var type = '1h';
            var timeshift = 60;
          } else {
            var type = '30m';
            var timeshift = 30;
          }

          // setting despawn and spawn time
          despawntime.minute(endMinute);
          despawntime.second(endSecond);
          var spawntime = moment(despawntime);
          spawntime.subtract(timeshift, 'm');

          if (despawntime.isBefore(now)) {
            // already despawned. shifting hours
            spawntime.add(1, 'h');
            despawntime.add(1, 'h');
          }

          if (now.isBetween(spawntime, despawntime)) {
            var activeText = `<span class="text-success">(active <i class="fa fa-ghost"></i>)</span>`;
          } else {
            var activeText = "";
          }

          var spawntiming = `
            <div class="spawn"><i class="fa fa-hourglass-start"></i> Spawn: <strong>${spawntime.format(timeformat)} ${activeText}</strong></div>
            <div class="despawn"><i class="fa fa-hourglass-end"></i> Despawn: <strong>${spawntime.format(timeformat)}</strong></div>`;
        } else {
          var spawntiming = "";
        }

        return `<div class="content">
            <div class="spawnContent">
            <div class="spawnType"><i class="fa fa-wrench"></i> Type: <strong>${type || "Unknown"}</strong> spawnpoint</div>
              <div class="spawnTiming">${spawntiming}</div>
            </div>
            <div class="id"><i class="fa fa-fingerprint"></i> <span>${spawn['id']}</span></div>
            <div class="coords">
              <i class="fa fa-map-pin"></i>
              <a href="https://maps.google.com/?q=${spawn['lat']},${spawn['lon']}">${spawn['lat']}, ${spawn['lon']}</a>
           </div>`;
      },
      getStoredSetting(name, defaultval) {
        var val = localStorage.getItem('settings');
        if (val == null) {
          return defaultval;
        }

        var settings = JSON.parse(val);
        if (settings[name] === undefined) {
          return defaultval;
        }

        return settings[name];
      },
      updateStoredSetting(name, value) {
        var settings = {};
        var storedSettings = localStorage.getItem('settings');
        if (storedSettings != null) {
          settings = JSON.parse(storedSettings);
        }

        settings[name] = value;
        localStorage.setItem('settings', JSON.stringify(settings));
      },
      removeStoredSetting(name) {
        var settings = {};
        var storedSettings = localStorage.getItem('settings');
        if (storedSettings != null) {
          settings = JSON.parse(storedSettings);
        }

        delete settings[name];

        localStorage.setItem('settings', JSON.stringify(settings));
      },
      l_event_moveend() {
        var $this = this;
        var center = map.getCenter();
        this.updateStoredSetting('center', center.lat + ',' + center.lng);
        this.updateBounds();

        // TODO remove this
        setTimeout(function() { $this.map_fetch_everything() }, 100);
      },
      l_event_zoomed() {
        var $this = this;
        this.updateStoredSetting('zoomlevel', map.getZoom());
        this.updateBounds();

        // update gym radius dynamically
        Object.keys(leaflet_data["gyms"]).forEach(function(id) {
          leaflet_data["gyms"][id].setRadius(Math.pow((20 - map.getZoom()), 2.5));
        });

        // TODO remove this
        setTimeout(function() { $this.map_fetch_everything() }, 100);
      },
      l_event_click(e) {
        $this = this;
        mapclick = mapclick + 1;

        setTimeout(function() {
          if(mapclick == 1) {
            $('#injectionModal').data('coords', e.latlng.lat + ',' + e.latlng.lng).modal();
            mapclick = 0;
          }
        }, 250);
      },
      l_event_dbclick(e) {
        mapclick = 0;
      },
      updateBounds(isOld) {
        if (!isOld) {
          var neLat = "neLat";
          var neLon = "neLon";
          var swLat = "swLat";
          var swLon = "swLon";
        } else {
          var neLat = "oNeLat";
          var neLon = "oNeLon";
          var swLat = "oSwLat";
          var swLon = "oSwLon";
        }

        var bounds = map.getBounds();
        this.updateStoredSetting(neLat, bounds.getNorthEast().lat);
        this.updateStoredSetting(neLon, bounds.getNorthEast().lng);
        this.updateStoredSetting(swLat, bounds.getSouthWest().lat);
        this.updateStoredSetting(swLon, bounds.getSouthWest().lng);
      },
      injectLocation() {
        $.ajax({
          type: "GET",
          url: 'send_gps?origin=' + $('#injectionWorker').val() +
            '&coords=' + $('#injectionModal').data('coords') +
            '&sleeptime=' + $('#injectionSleep').val()
        });
      },
      convertToLonLat(coords) {
        lonlat = []
        coords.forEach(function (coord) {
          lonlat.push([coord[1], coord[0]]);
        });
        return lonlat;
      },
      initMap() {
        $this = this;

        // get stored center and zoom level if they exists
        const storedZoom = this.getStoredSetting('zoomlevel', 3);
        const storedCenter = this.getStoredSetting('center', '52.521374,13.411201');
        const layer = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png');

        // get stored coordinate radius
        this.settings.routes.coordinateRadius.raids = this.getStoredSetting('settings-coordinateRadius-raids', 490);
        this.settings.routes.coordinateRadius.quests = this.getStoredSetting('settings-coordinateRadius-quests', 40);
        this.settings.routes.coordinateRadius.mons = this.getStoredSetting('settings-coordinateRadius-mons', 67);

        // get stored static layer settings
        var statlayers = Object.keys(this.layers.stat);
        for (index of Object.keys(this.layers.stat)) {
          this.layers.stat[index] = this.getStoredSetting("layer-stat-"+index, false);
        }

        map = L.map('map', {
          layers: [layer],
          zoomControl: false,
          updateWhenZooming: false,
          updateWhenIdle: true,
          preferCanvas: true
        }).setView(storedCenter.split(','), storedZoom);

        L.control.zoom({
          position: 'bottomright'
        }).addTo(map);

        var sidebar = L.control.sidebar({
          autopan: false,
          closeButton: true,
          container: "sidebar",
          position: "left",
        }).addTo(map);

        sidebar.close();

        {% if setlat and setlng %}
        var setlat = {{ setlat }};
        var setlng = {{ setlng }};

        if(setlat != 0 && setlng != 0) {
            var circle = L.circle([setlat, setlng], {
            color: 'blue',
            fillColor: 'blue',
            fillOpacity: 0.5,
            radius: 30
          }).addTo(map);

          map.setView([setlat, setlng], 20);
        };
        {% endif %}

        map.on('zoomend', this.l_event_zoomed);
        map.on('moveend', this.l_event_moveend);
        map.on('click', this.l_event_click);
        map.on('dblclick', this.l_event_dbclick);

        sidebar.on("content", function(event) {
          $this.updateStoredSetting("sidebartab", event.id);
        });
      },
      buildUrlFilter(force = false) {
        var oSwLat = this.getStoredSetting("oSwLat", null);
        var oSwLon = this.getStoredSetting("oSwLon", null);
        var oNeLat = this.getStoredSetting("oNeLat", null);
        var oNeLon = this.getStoredSetting("oNeLon", null);

        var old = {};
        if (oSwLat && oSwLon && oNeLat && oNeLon && !force) {
          old = {
            "oSwLat": oSwLat,
            "oSwLon": oSwLon,
            "oNeLat": oNeLat,
            "oNeLon": oNeLon
          };
        }

        var timestamp = this.getStoredSetting("fetchTimestamp", null);
        if (timestamp && !force) {
          old["timestamp"] = timestamp;
        }

        var swLat = this.getStoredSetting("swLat", null);
        var swLon = this.getStoredSetting("swLon", null);
        var neLat = this.getStoredSetting("neLat", null);
        var neLon = this.getStoredSetting("neLon", null);

        var bounds = {
          "swLat": swLat,
          "swLon": swLon,
          "neLat": neLat,
          "neLon": neLon
        };

        Object.keys(old).forEach(function(key) { bounds[key] = old[key]; });
        var querystring = new URLSearchParams(bounds).toString();

        // temp: update last update timestamp
        this.updateStoredSetting("fetchTimestamp", Math.floor(Date.now() / 1000))

        return "?" + querystring;
      }
    }
  });
</script>
{% endblock %}

{% block content %}
<div id="app">
  <div id="sidebar" class="leaflet-sidebar">
    <div class="leaflet-sidebar-tabs">
      <ul role="tablist">
        <li><a href="#points" role="tab"><i class="fa fa-map-marker"></i></a></li>
        <li><a href="#routes" role="tab"><i class="fa fa-route"></i></a></li>
        <li><a href="#geofences" role="tab"><i class="fa fa-draw-polygon"></i></a></li>
        <li><a href="#settings" role="tab"><i class="fa fa-cog"></i></a></li>
      </ul>
    </div>

    <div class="leaflet-sidebar-content">
      <div class="leaflet-sidebar-pane" id="points">
        <h1 class="leaflet-sidebar-header bg-dark">Points<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <ul class="list-group list-group-flush">
          {% raw %}
          <li v-for="(item, index) in layers.stat" class="list-group-item layer-item d-flex">
            <div class="flex-grow-1">{{ index }}</div>
            <div class="custom-control custom-switch">
              <input :id="index" type="checkbox" v-model="layers.stat[index]" class="custom-control-input" />
              <label :for="index" class="custom-control-label"></label>
            </div>
          </li>
          {% endraw %}
        </ul>
      </div>

      <div class="leaflet-sidebar-pane" id="routes">
        <h1 class="leaflet-sidebar-header bg-dark">Routes<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <ul class="list-group list-group-flush">
          {% raw %}
          <li v-for="(route, index) in layers.dyn.routes" class="list-group-item layer-item justify-content-between d-flex align-items-center">
            <div class="flex-grow-1">{{ index }}</div>
            <span class="badge badge-secondary" style="margin-right: 5px;">{{ route.mode }}</span>
            <div class="custom-control custom-switch">
              <input :id="index" type="checkbox" v-model="route.show" class="custom-control-input" />
              <label :for="index" class="custom-control-label"></label>
            </div>
          </li>
          {% endraw %}
        </ul>
      </div>

      <div class="leaflet-sidebar-pane" id="geofences">
        <h1 class="leaflet-sidebar-header bg-dark">Geofences<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <ul class="list-group list-group-flush">
          {% raw %}
          <li v-for="(fence, index) in layers.dyn.geofences" class="list-group-item layer-item d-flex">
            <div class="flex-grow-1">{{ index }}</div>
            <div class="custom-control custom-switch">
              <input :id="'fence'+index" type="checkbox" v-model="fence.show" class="custom-control-input" />
              <label :for="'fence'+index" class="custom-control-label"></label>
            </div>
          </li>
          {% endraw %}
      </div>

      <div class="leaflet-sidebar-pane" id="settings">
        <h1 class="leaflet-sidebar-header bg-dark">Settings<div class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></div></h1>
        <ul class="list-group list-group-flush">
          <li class="list-group-item layer-item d-flex">
            <div class="flex-grow-1"><strong>Raids visual radius</strong></div>
            <div class="custom-control custom-switch">
              <input id="raidcoordinateradius" type="number" v-model="settings.routes.coordinateRadius.raids" max="1100" class="form-control form-control-sm" />
            </div>
          </li>
          <li class="list-group-item layer-item d-flex">
            <div class="flex-grow-1"><strong>Mons visual radius</strong></div>
            <div class="custom-control custom-switch">
              <input id="moncoordinateradius" type="number" v-model="settings.routes.coordinateRadius.mons" max="1100" class="form-control form-control-sm" />
            </div>
          </li>
          <li class="list-group-item layer-item d-flex">
            <div class="flex-grow-1"><strong>Quests visual radius</strong></div>
            <div class="custom-control custom-switch">
              <input id="questcoordinateradius" type="number" v-model="settings.routes.coordinateRadius.quests" max="1100" class="form-control form-control-sm" />
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <div class="modal fade" id="injectionModal" tabindex="-1" role="dialog" aria-labelledby="injectionModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="injectionModalLabel">Inject Location</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>

        <div class="modal-body">
          <p>Would you like to send a scanner to update this location?</p>
          <select id="injectionWorker" class="form-control">
            {% raw %}
            <option v-for="worker in workers">
              {{ worker.name }}
            </option>
            {% endraw %}
          </select>

          <p>Extra sleep time (in seconds, optional):</p>
          <input type="number" class="form-control" id="injectionSleep" value="0">
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">No</button>
          <button type="button" class="btn btn-primary" v-on:click="injectLocation" data-dismiss="modal">Yes</button>
        </div>
      </div>
    </div>
  </div>

  <div id="map"></div>
</div>
{% endblock %}
